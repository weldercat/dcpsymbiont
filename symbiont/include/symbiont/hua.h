/*
 * Copyright 2017,2018 Stacy <stacy@sks.uz> 
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#ifndef HUA_HDR_LOADED_
#define HUA_HDR_LOADED_
#include "sigtran.h"
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#define HUA_OK		0
#define HUA_FAIL	(-1)
#define	HUA_AGAIN	(-2)
#define HUA_EOF		(-3)

#define DEFAULT_NWORKERS	3
#define MAX_NWORKERS		32
#define DEFAULT_HUA_PORT	9900
#define DEFAULT_HUA_PPID	61
#define HUA_MAX_MSG_SIZE	8192
#define HUA_MIN_MSG_SIZE	16
#define HUA_IFI_SIZE		4
#define HUA_DEFAULT_OVERHEAD	20

enum hua_conn_state {
	HUA_SCTP_DOWN = 0,
	HUA_SCTP_TRYING,
	HUA_SCTP_UP,
};

enum hua_asp_state {
	HUA_ASP_DOWN,
	HUA_ASP_INACTIVE,
	HUA_ASP_ACTIVE
};

struct interface_s {
	uint32_t	ifi;
	uint16_t	stream;
	void		*userdata;
};

struct ifshell_s;

struct ifshell_s {
	struct ifshell_s *next;
	struct ifshell_s *prev;
	struct interface_s iface;
};

#define IFID_HASHBITS		6
#define IFTABLE_SIZE		(1 << (IFID_HASHBITS))
#define IFTABLE_IDX_MASK	(IFTABLE_SIZE - 1)
#define DEFAULT_SIDSTACK_ENTRIES	512
#define SIDSTACK_GROW_PACE		512

#define MAX_SID			65535

typedef struct hua_ctx_s {
	int	fd;
	int	ppid;
	int	maxstreams;
	struct sockaddr_in remote;
	bool	client;
	bool	connected;
	pthread_mutex_t	state_mutex;
	int	conn_state;
	int	nworkers;
	pthread_t	workers[MAX_NWORKERS];
	pthread_mutex_t rcv_mutex;	/* thundering herd prevention upon sctp_recvmsg() */

	pthread_rwlock_t iftab_rwlock;
	int	ifcount;	/* active interfaces count */
	struct	ifshell_s *shells[IFTABLE_SIZE];

	pthread_mutex_t	sidfactory_mutex;
	int	max_sid;	/* maximum issued sid */
	int	stacktop;	/* index to stack top */
	int	stacklen;	/* max entries that can be put into stack */
	uint16_t	*sidstack;	/* released sids stack */

} hua_ctx;

/* 
 * Each interface is identified by ifi. It can be added 
 * to the context when configured and dropped when 
 * no longer active. 
 */

struct interface_s *hua_find_iface(hua_ctx *ctx, int ifi);
int hua_add_iface(hua_ctx *ctx, struct interface_s *iface);
int hua_drop_iface(hua_ctx *ctx, int ifi);

/*
 * d-channels data are sent within different sctp streams - 
 * each d-chan in it's own stream preferably. 
 * Streams ID are generated by the fabric using get_sid() when 
 * there is need for new sid for an interface.
 * sids are released when the interface in question is no longer 
 * active (for ex. disabled by operator)
 */
 
uint16_t hua_get_sid(hua_ctx *ctx);
void	hua_release_sid(hua_ctx *ctx, uint16_t sid);

/* receiver callback is called by hua receiver thread */
typedef void (*hua_receiver)(int ifi, uint8_t *data, int datalen, void *arg);

/* set socket blocking/non-blocking mode.
 * works only if nowrkers == 0
 */

int hua_set_nonblocking(hua_ctx *ctx, bool nb);


/*
 * send data to a HUA peer.
 * returns number of bytes sent or -1 in case of error
 */
int hua_send_data(hua_ctx *ctx, int ifi, uint8_t *data, int datalen);


/*
 * alternative interface if one wants to do one's own net side I/O:
 * message is the pointer to recieved packet data,
 * returns pointer to protocol data in *data, data length in *datalen, 
 * interface idientifier in *ifi
 * Returns NULL in *data and zero in *datalen if packet format is bad. */

void hua_parse_pkt(uint8_t *message, int msglen, int *ifi, uint8_t **data, int *datalen);

/* alternate interface if no workers were started 
 * message is the pointer to the message buffer 
 * maxlen bytes long.
 * returns received message length.
 */
int hua_read_pkt(hua_ctx *ctx, uint8_t *message, int maxlen);

/* assemble complete message to send to other side of HUA link 
 * returns xrn_pktbuf describing the assembled message.or null
 * in case of any error (mailloc failed for ex)
 *
 * use xrn_free_pkt(p) to free returned pktbuf.
 * use xrn_dataptr(p) and xrn_datalen(p) to access
 * assembled packet data and length respectively.
 * see sigtran.h for more info on xrn_pktbuf
 */
xrn_pktbuf *hua_assemble_pkt(int ifi, uint8_t *data, int datalen);


/* dest - is the <ip_addr>:<port>_<ppid> string where:
 * hostname is the host to connect to,
 * port is the server port number
 * and ppid is the payload protocol ID for the SCTP
 *
 * if rcvr is NULL or nworkers == 0 then no workers will be started and
 * caller has to poll socket fd and call hua_read_pkt() when needed 
 */ 
 
hua_ctx *hua_connect(const char *dest, hua_receiver rcvr, void *rcvarg, int nworkers);

hua_ctx *hua_listen(const char *bindstr, hua_receiver rcvr, void *rcvarg, int nworkers);

void hua_shutdown(hua_ctx *ctx);

/* this is for debug purposes only *
 * don't call in production env *
 */
void hua_debug_ctl(int dbgval1);


#endif /* HUA_HDR_LOADED_ */


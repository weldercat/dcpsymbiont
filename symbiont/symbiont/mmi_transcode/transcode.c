/*
 * Copyright 2018 Stacy <stacy@sks.uz> 
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */


#define _GNU_SOURCE	1

#include <stdbool.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <stdio.h>
#include <symbiont/hua.h>
#include <symbiont/symerror.h>
#include <symbiont/mmi.h>
#include <symbiont/dcphdlc.h>

#include <symbiont/transcode.h>
#include "dcp_resp.c"	/* autogenerated by gperf */


/* converts dcp report to mmi event 
 * returns SYM_OK if converted ok
 * or SYM_FAIL if dcp report from terminal was unrecognized
 */

static int dcp2evt(unsigned char *data, size_t datalen, struct mmi_event *evt);


/*
 * converts mmi command to dcp command
 * returns dcp command data lenght */
ssize_t cmd2dcp(struct mmi_command *cmd, unsigned char *data, size_t maxlen);
static bstring decode_dcp_key(unsigned char *data, size_t datalen);
static bstring decode_dcp_pad(unsigned char *data, size_t datalen);
static bstring decode_dcp_menu(unsigned char *data, size_t datalen);
static bstring decode_dcp_prg(unsigned char *data, size_t datalen);

static struct dcp_dblk *new_dblk(void);
static void dtrain_append(struct dcp_dblk **dtrain, unsigned const char *data, size_t len);

static void put8csum(unsigned char *data, unsigned char byte, uint16_t *csum);
static ssize_t dcp_encode_led(struct dcp_dblk **dtrain, bstring ledname, struct mmi_led_arg *led);
static ssize_t dcp_encode_menu(struct dcp_dblk **dtrain, struct mmi_program_arg *item);
static ssize_t dcp_encode_lines(struct dcp_dblk **dtrain, struct mmi_text_arg *text);
static ssize_t dcp_encode_erase(struct dcp_dblk **dtrain, struct mmi_text_arg *text);
static ssize_t dcp_encode_pos(struct dcp_dblk **dtrain, struct mmi_text_arg *text);



struct dcp_cmdstr_s {
	const char *p;
	size_t	l;
};


struct dcp_cmdstr_s dcpc_l[MMI_CMD_UNUSED+1] = {
	{ .p = NULL, .l = 0},	/* Undefined */
	{ .p = NULL, .l = 0},	/* LED */
	{ .p = NULL, .l = 0},	/* PROGRAM */
	{ .p = NULL, .l = 0},	/* TEXT */
	{ .p = "\x80\x0e", .l = 2},	/* ONHOOK */
	{ .p = "\x80\x0f", .l = 2},	/* OFFHOOK */
	{ .p = "\x80\x03\x00", .l = 3},	/* NORING */
	{ .p = "\x80\x03\x01", .l = 3},	/* BEEP ONCE */
	{ .p = "\x80\x03\x09", .l = 3},	/* BEEP  */
	{ .p = "\x80\x03\x0e", .l = 3},	/* RING ONCE */
	{ .p = "\x80\x03\x0b", .l = 3},	/* RING1 */
	{ .p = "\x80\x03\x0c", .l = 3},	/* RING2 */
	{ .p = "\x80\x03\x0d", .l = 3},	/* RING3 */
	{ .p = "\x83\x04\x01", .l = 3},	/* TMR START */
	{ .p = "\x83\x04\x02", .l = 3},	/* TMR STOP */
	{ .p = "\x80\x0a", .l = 2},	/* Terminal INIT */
	{ .p = "\xa0\x0b", .l = 2}, 	/* IDENTIFY */
	{ .p = "\x83\x04\x41", .l = 3},	/* ECHO ON */
	{ .p = "\x83\x04\x42", .l = 3},	/* ECHO OFF */
	{ .p = "\x83\x04\x04", .l = 3},	/* SCROLL DOWN */
	{ .p = "\x83\x04\x03", .l = 3},	/* RESET SCROLL */
	{ .p = "\x80\x05", .l = 2},	/* Keypad to DTMF */
	{ .p = "\x80\x06", .l = 2},	/* Keypad to events */
	{ .p = "\x80\x09\x00", .l = 3},	/* Set ring pattern 1 */
	{ .p = "\x80\x09\x01", .l = 3},	/* Set ring pattern 2 */
	{ .p = "\x80\x09\x02", .l = 3},	/* Set ring pattern 3 */
	{ .p = "\x80\x09\x03", .l = 3},	/* Set ring pattern 4 */
	{ .p = "\x80\x09\x04", .l = 3},	/* Set ring pattern 5 */
	{ .p = "\x80\x09\x05", .l = 3},	/* Set ring pattern 6 */
	{ .p = "\x80\x09\x06", .l = 3},	/* Set ring pattern 7 */
	{ .p = "\x80\x09\x07", .l = 3},	/* Set ring pattern 8 */
	{ .p = NULL, .l = 0 }
};


struct dcp_cmdstr_s dcpc_enable_prg = { .p = "\xe1\xa3\xc5\x00", .l = 4 };
struct dcp_cmdstr_s dcpc_keypad_dtmf = { .p = "\x80\x05", .l = 2 };
struct dcp_cmdstr_s dcpc_keypad_msg = { .p = "\x80\x06", .l = 2 };
struct dcp_cmdstr_s dcpc_reset = { .p = "\x80\x0a", .l = 2 };
struct dcp_cmdstr_s dcpc_ident = { .p = "\xa0\x0b", .l = 2 };


struct mmi_event *dcp2mmi(uint8_t *data, int length)
{
	struct mmi_event *evt;
	int res;
	
	assert(data);
	assert(length >= 0);
	
	if (!length) return NULL;
	evt = malloc(sizeof(struct mmi_event));
	if (!evt) SYMFATAL("cannot allocate memory\n");
	memset(evt, 0, sizeof(struct mmi_event));
	res = dcp2evt(data, length, evt);
	if (res != SYM_OK) {
		if (evt->ctlname) bdestroy(evt->ctlname);
		evt->ctlname = NULL;
		if (evt->station) bdestroy(evt->station);
		evt->station = NULL;
		free(evt);
	}
	return evt;
}

struct mmi_event *mmi_up(void)
{
	struct mmi_event *evt;
	
	evt = malloc(sizeof(struct mmi_event));
	if (!evt) SYMFATAL("cannot allocate memory\n");
	memset(evt, 0, sizeof(struct mmi_event));
	evt->type = MMI_EVT_UP;
	return evt;
}

struct mmi_event *mmi_lost(void)
{
	struct mmi_event *evt;
	
	evt = malloc(sizeof(struct mmi_event));
	if (!evt) SYMFATAL("cannot allocate memory\n");
	memset(evt, 0, sizeof(struct mmi_event));
	evt->type = MMI_EVT_LOST;
	return evt;
}


/* decodes dcp data from terminal and converts it to mmi event */

static int dcp2evt(unsigned char *data, size_t datalen, struct mmi_event *evt)
{
	const struct dcp_status_s *ds;
	int	i;
	int	res;
	
	assert(data);
	assert(evt);
	if (datalen < DCP_CMD_PREFIX_LEN) return SYM_FAIL;
	
	ds = decode_dcp_resp((const char *)data, DCP_CMD_PREFIX_LEN);
	if (!ds) return SYM_FAIL;
	if (evt->ctlname) {
		bdestroy(evt->ctlname);
		evt->ctlname = NULL;
	}
	data += DCP_CMD_PREFIX_LEN;
	datalen -= DCP_CMD_PREFIX_LEN;
	switch (ds->type) {
		case DCP_ST_HWID:
			evt->type = MMI_EVT_INIT;
			evt->ctlname = bfromcstr("hwid_");
			for (i = 0; i < datalen; i++) {
				res = bformata(evt->ctlname, "%.2x", data[i]);
				assert(res == BSTR_OK);
			}
			break;
		case DCP_ST_OFFHOOK:
			evt->type = MMI_EVT_OFFHOOK;
			evt->ctlname = bfromcstr("hookswitch");
			break;
		case DCP_ST_ONHOOK:
			evt->type = MMI_EVT_ONHOOK;
			evt->ctlname = bfromcstr("hookswitch");
			break;
		case DCP_ST_KEY:
			evt->type = MMI_EVT_PRESS;
			evt->ctlname = decode_dcp_key(data, datalen);
			break;
		case DCP_ST_PAD_PRESS:
			evt->type = MMI_EVT_PRESS;
			evt->ctlname = decode_dcp_pad(data, datalen);
			break;
		case DCP_ST_PAD_RELEASE:
			evt->type = MMI_EVT_RELEASE;
			evt->ctlname = decode_dcp_pad(data, datalen);
			break;
		case DCP_ST_MENU_EXIT:
			evt->type = MMI_EVT_MENU_EXIT;
			evt->ctlname = bfromcstr("menu/exit");
			break;
		case DCP_ST_MENU_ITEM:
			evt->type = MMI_EVT_MENU_SELECT;
			evt->ctlname = decode_dcp_menu(data, datalen);
			break;
		case DCP_ST_PRG_RESULT:
				if (*data == 00) evt->type = MMI_EVT_MENU_SAVED;
				else evt->type = MMI_EVT_PRG_FAILED;
				evt->ctlname = decode_dcp_prg(data, datalen);
			break;
		default:
			SYMWARNING("Unknown dcp command\n"); 
			return SYM_FAIL;
	}
	return SYM_OK;
}



/* 
 * decodes dcp key number from keypress data and converts it 
 * to key name
 */
static bstring decode_dcp_key(unsigned char *data, size_t datalen)
{
	enum {
		FIRST_FUNCTION_KEY = 0x04,
		LAST_FUNCTION_KEY = 0x0a,
		FIRST_BLF_KEY = 0x0e,
		LAST_BLF_KEY = 0x50
	};
	static const char *fkey_names[] = {
		"drop", "conf", "transfer", "hold" };
	bstring res = NULL;
	unsigned char c = '\000';
	
	assert(data);
	if (datalen < 1) res = bfromcstr("unknown");
	else { 
		c = *data;
		if ((c >= FIRST_FUNCTION_KEY) && (c <= LAST_FUNCTION_KEY)) {
			res = bfromcstr(fkey_names[((c - FIRST_FUNCTION_KEY) / 2)] );
		} else if ((c >= FIRST_BLF_KEY) && (c <= LAST_BLF_KEY)) {
			res = bformat("blf%d", ((c - FIRST_BLF_KEY) / 2) + 1);
		} else res = bfromcstr("unknown");
	}
	return res;
}


/* 
 * decodes dcp dtmf keypad key number from press/release data 
 * and converts it to keypad key name
 */
static bstring decode_dcp_pad(unsigned char *data, size_t datalen)
{
	enum {
		FIRST_KEYPAD_KEY = 0x02,
		LAST_KEYPAD_KEY = 0x18
	};
	static const char keypads[] = {
		'1', '2', '3', 
		'4', '5', '6',
		'7', '8', '9',
		'0', '*', '#' };
	bstring res = NULL;
	unsigned char c = '\000';

	assert(data);
	if (datalen < 1) res = bfromcstr("pad/unknown");
	else {
		c = *data;
		if ((c >= FIRST_KEYPAD_KEY) && ( c <= LAST_KEYPAD_KEY)) {
			res = bformat("pad/%c", keypads[((c - FIRST_KEYPAD_KEY) / 2 )] );
		} else res = bfromcstr("pad/unknown");
	}
	return res;
}

static bstring decode_dcp_prg(unsigned char *data, size_t datalen)
{
	bstring res = NULL;
	
	assert(data);
	if (datalen < 1) res = bfromcstr("program/fail");
	switch (*data) {
		case 0x00:	
			res = bfromcstr("program/ok");
			break;
		case 0x01: 
			res = bfromcstr("program/fail_off_hook");
			break;
		case 0x02:
			res = bfromcstr("program/fail_checksum");
			break;
		case 0x05:
			res = bfromcstr("program/fail_not_enabled");
			break;
		default:
			res = bfromcstr("program/fail_unknown");
	}
	return res;
}

/* decodes dcpmenu item number and converts it to item name */
static bstring decode_dcp_menu(unsigned char *data, size_t datalen)
{
	enum {
		FIRST_MENU_ITEM = 0x02,
		LAST_MENU_ITEM = 0x1e
	};
	bstring res = NULL;
	unsigned char c = '\000';
	
	assert(data);
	if (datalen < 1) res = bfromcstr("menu/unknown");
	else {
		c = *data;
		if ((c >= FIRST_MENU_ITEM) && ( c <= LAST_MENU_ITEM)) {
			res = bformat("menu/item%d", ((c - FIRST_MENU_ITEM) / 2) + 1);
		} else res = bfromcstr("menu/unknown");
	}
	return res;
}


static struct dcp_dblk *new_dblk(void)
{
	struct dcp_dblk	*db;
	
	db = malloc(sizeof(struct dcp_dblk));
	if (!db) {
		SYMFATAL("cannot allocate memory\n");
		assert(0);
	}
	memset(db, 0, sizeof(struct dcp_dblk));
	return db;
}

static void dtrain_append(struct dcp_dblk **dtrain, unsigned const char *data, size_t len)
{
	struct dcp_dblk	*db;
	int	blklen;
	
	assert(dtrain);
	assert(data);
	assert(len > 0);
	db = *dtrain;
	if (!db) {
		db = new_dblk();
		*dtrain = db;
	} else {
		while(db->next) db = db->next;
	}
	while (len > 0) {
		if (db->length > 0) {
			assert(db->next == NULL);
			db->next = new_dblk();
			db = db->next;
		}
		blklen = len;
		if (blklen > DBLK_MAXLEN) blklen = DBLK_MAXLEN;
		memcpy(db->data, data, blklen);
		db->length = blklen;
		data += blklen;
		len -= blklen;
	}
	assert(*dtrain);
}


void free_dblks(struct dcp_dblk *dtrain)
{
	struct dcp_dblk	*nptr;
	
	assert(dtrain);
	
	while (dtrain->next) {
		nptr = dtrain->next;
		free(dtrain);
		dtrain = nptr;
	}
	free(dtrain);
}

struct dcp_dblk *mmi2dcp(struct mmi_command *cmd)
{
	struct dcp_dblk	*dtrain = NULL;
	const char *ds;
	ssize_t	dl = 0;
	int	datalen = -1;
	
	assert(cmd);
	switch (cmd->type) {
		case MMI_CMD_UNDEFINED:
			SYMFATAL("Trying to encode uninitialized mmi cmd, abort\n");
			break;
		case MMI_CMD_LED:
			datalen = dcp_encode_led(&dtrain, cmd->ctlname, &cmd->arg.led_arg);
			break;
		case MMI_CMD_PROGRAM:
			dtrain_append(&dtrain, (unsigned const char *)dcpc_enable_prg.p, dcpc_enable_prg.l);
			datalen = dcpc_enable_prg.l;
			datalen += dcp_encode_menu(&dtrain, &cmd->arg.program_arg);
			break;
		case MMI_CMD_TEXT:
			if (cmd->arg.text_arg.erase == MMI_ERASE_ALL) {
				datalen = dcp_encode_erase(&dtrain, &cmd->arg.text_arg);
				datalen += dcp_encode_pos(&dtrain, &cmd->arg.text_arg);
			} else {
				datalen = dcp_encode_pos(&dtrain, &cmd->arg.text_arg);
				datalen += dcp_encode_erase(&dtrain, &cmd->arg.text_arg);
			}
			datalen += dcp_encode_lines(&dtrain, &cmd->arg.text_arg);
			break;
		default:
			ds = (dcpc_l[cmd->type]).p;
			dl = (dcpc_l[cmd->type]).l;
			if ((ds == NULL) || (dl <= 0)) {
				SYMERROR("unknown mmi command %d, ignored\n", cmd->type);
				break;
			}
			dtrain_append(&dtrain, (unsigned const char *)ds, dl);
			datalen = dl;
			break;
	}
	SYMDEBUG("dcp cmd train created with overall length=%d\n", datalen);
	return dtrain;
}



/* convert led description into dcp command *
 *	ledname is parsed for blf# where # is the led number
 *	or for "mwi" - for message waiting led.
 * 	colors are interpreted as follows:
 *	red and green affects respective leds.
 *	yellow is interpreted as red.
 *	blue and white are interpreted as green.
 *
 *	color is ignored for MWI.
 */
#define LNAME_MIN_LEN	3
#define LNAME_MWI_LEN	3
#define LNAME_BLF_LEN	3
#define LNAME_MWI_STR	"mwi"
#define LNAME_BLF_STR	"blf"

static ssize_t dcp_encode_led(struct dcp_dblk **dtrain, bstring ledname, struct mmi_led_arg *led)
{
	int	lednum;
	char	*p;
	int	len;
	unsigned char mode = 0;
	unsigned char data[HDLC_DATA_LEN];
	
	enum {
		FIRST_BLF_LED = 0x0e,
		LAST_BLF_LED = 0x51,
		RED_LED_OFFSET = 0,
		GREEN_LED_OFFSET = 1,
		MWI_LED = 0x0d,
		LED_COMMAND_LEN = 3
	};
	
	assert(ledname);
	assert(led);
	assert(dtrain);

	len = blength(ledname);
	p = bdata(ledname);
	if (len < LNAME_MIN_LEN) return SYM_FAIL;
	if (!p) return SYM_FAIL;
	
	if (strncmp(p, LNAME_MWI_STR, LNAME_MWI_LEN) == 0) {
		lednum = MWI_LED;
	} else if (strncmp(p, LNAME_BLF_STR, LNAME_BLF_LEN) == 0) {
		len -= LNAME_BLF_LEN;
		if (len <= 0) return SYM_FAIL;
		p += LNAME_BLF_LEN;
		lednum = strtol(p, NULL, 10);
		lednum -= 1;
		if (lednum < 0) lednum = 0;
		lednum = (lednum * 2) + FIRST_BLF_LED;
		switch (led->color) {
			case LED_COLOR_BLUE:
			case LED_COLOR_WHITE:
			case LED_COLOR_GREEN:
				lednum += GREEN_LED_OFFSET;
				break;
			case LED_COLOR_RED:
				lednum += RED_LED_OFFSET;
				break;
			default:
				SYMERROR("Invalid LED color %d\n", led->color);
				return SYM_FAIL;
				break;
		}
		if (lednum > LAST_BLF_LED) SYMWARNING("Led number > 0x%0x which is max for 8434DX\n",
				LAST_BLF_LED);
	} else return SYM_FAIL;
	switch (led->mode) {
		case LIGHT_OFF:
			mode = 0;
			break;
		case LIGHT_STEADY:
			mode = 0x0f;
			break;
		case LIGHT_DARKENING:
			mode = 0x02;
			break;
		case LIGHT_SLOWFLASH:
			mode = 0x03;
			break;
		case LIGHT_MEDIUMFLASH:
			mode = 0x08;
			break;
		case LIGHT_FASTFLASH:
			mode = 0x0a;
			break;
		case LIGHT_FLUTTER:
			mode = 0x0d;
			break;
		default:
			SYMWARNING("Unknown led mode - replaced by LIGHT_STEADY\n");
			mode = 0x0f;
			break;
	}
	data[0] = 0x80;
	data[1] = mode | 0x20;
	data[2] = lednum & 0xff;
	dtrain_append(dtrain, data, LED_COMMAND_LEN);
	return LED_COMMAND_LEN;
}

static void put8csum(unsigned char *data, unsigned char byte, uint16_t *csum)
{
	assert(data);
	assert(csum);
	*data = byte;
	*csum += byte;
}


/* 
 * This function encodes only final command for the 
 * menu programming. The one that contains actual item text.
 * 
 */

static ssize_t dcp_encode_menu(struct dcp_dblk **dtrain, struct mmi_program_arg *item)
{
	enum {
		MENU_ITEM_LEN = 5,
		MENU_COMMAND_LEN = 11
	};
	uint16_t sum = 0;
	char itmtxt[MENU_ITEM_LEN];
	int	mnumber, i, srclen;
	char *src;
	unsigned char *data;
	unsigned char buffer[HDLC_DATA_LEN];
	
	assert(item);
	assert(dtrain);
	data = &buffer[0];
	mnumber = item->number;
	if (mnumber > 255) {
		SYMERROR("Menu item number %d > 255\n", mnumber);
		return SYM_FAIL;
	}
	for (i = 0; i < MENU_ITEM_LEN; i++) itmtxt[i] = ' ';
	if (item->text) {
		srclen = blength(item->text);
		src = bdata(item->text);
		if (srclen > MENU_ITEM_LEN) srclen = MENU_ITEM_LEN;
		if (src && (srclen > 0)) strncpy(&itmtxt[0], src, srclen);
	}
	*data++ = 0xe1;	/* programming prefix */
	*data++ = 0x44; /* menu item programming prefix */
	put8csum(data++, (mnumber & 0xff), &sum);
	put8csum(data++, 0, &sum);
	for (i= 0; i < MENU_ITEM_LEN; i++) put8csum(data++, itmtxt[i], &sum);
	*data++ = sum & 0xff;
	*data = (sum >> 8) & 0xff;
	dtrain_append(dtrain, buffer, MENU_COMMAND_LEN);
	return MENU_COMMAND_LEN;
}

static ssize_t dcp_encode_pos(struct dcp_dblk **dtrain, struct mmi_text_arg *text)
{
	enum {
		POSITION_CMD_MAXLEN = 9
	};
	unsigned char data[HDLC_DATA_LEN];
	int	res;
	int	row, col;
	
	assert(text);
	assert(dtrain);
	if ((text->row == TEXT_CONTINUE) || (text->col == TEXT_CONTINUE))
		return 0;
	row = text->row & 0xff;
	if (row > 99) row = 99;
	col = text->col & 0xff;
	if (col > 99) col = 99;
	res = snprintf((char *)&data[0], POSITION_CMD_MAXLEN+1, "\xe3\x1b[%c;%cH", 
		row, col);
	assert(res > 0);
	if (res > POSITION_CMD_MAXLEN) res = POSITION_CMD_MAXLEN;
	dtrain_append(dtrain, &data[0], res);
	return res;
}

static ssize_t dcp_encode_erase(struct dcp_dblk **dtrain, struct mmi_text_arg *text)
{
	enum {
		ERASE_CMD_LEN = 5,
		ERASE_WITH_POS_LEN = 11
	};
	unsigned char erase_p = 2;	
	unsigned char data[HDLC_DATA_LEN];

	assert(text);
	assert(dtrain);
	if (text->erase == MMI_ERASE_NONE) return 0;
	switch (text->erase) {
		case MMI_ERASE_TAIL:
			erase_p = 0;
			break;
		case MMI_ERASE_HEAD:
			erase_p = 1;
			break;
		case MMI_ERASE_LINE:
			erase_p = 2;
			break;
		case MMI_ERASE_ALL:
			memcpy(&data[0], "\xe3\x1b[\x00;\x00H\x1b[\x02K", ERASE_WITH_POS_LEN);
			dtrain_append(dtrain, &data[0], ERASE_WITH_POS_LEN);
			memcpy(&data[0], "\xe3\x1b[\x03;\x00H\x1b[\x02K", ERASE_WITH_POS_LEN);
			dtrain_append(dtrain, &data[0], ERASE_WITH_POS_LEN);
			return (ERASE_WITH_POS_LEN * 2);
		default:
			SYMWARNING("unsupported erase condition %d, ignored\n", text->erase);
			return 0;
	}
	memcpy(&data[0], "\xe3\x1b[_K" ,ERASE_CMD_LEN);
	data[3] = erase_p;
	dtrain_append(dtrain, &data[0], ERASE_CMD_LEN);
	return ERASE_CMD_LEN;
}

static ssize_t dcp_encode_lines(struct dcp_dblk **dtrain, struct mmi_text_arg *text)
{
	int arglen, txtlen;
	int	res = 0;
	char	*p;
	unsigned char data[HDLC_DATA_LEN];

	assert(text);
	assert(dtrain);
	txtlen = blength(text->text);
	if (txtlen <= 0) return 0;
	p = bdata(text->text);
	if (!p) return 0;
	
	while (txtlen) {
		arglen = txtlen;
		if (arglen > (HDLC_DATA_LEN - 1)) arglen = (HDLC_DATA_LEN - 1);
		data[0] = 0xe3;
		strncpy((char *)&data[1], p, arglen);
		dtrain_append(dtrain, &data[0], arglen + 1);
		txtlen -= arglen;
		p += arglen;
		res += (arglen + 1);
	}
	return res; 
}
